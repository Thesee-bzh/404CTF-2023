# Retro / Encore une mise à jour !

## Challenge
« RAAAAAAH !! »

Un cri sourd se fait entendre près du comptoir. Vous vous approchez, curieux. Vous remarquez le propriétaire des lieux fou de rage.

« Encore cette satanée Terreur des Quincailliers, il a volé tout mon café ! Je vais devoir appeler l'inspecteur Blognard. Mais comment diable a-t-il fait ?
Vous ! Là ! Vous êtes la personne qui avez aidé les Hackademitiens toute la journée non ? »

Il vous pointe du doigt.

« Et bien ça tombe parfaitement, j'ai un mystère sur les bras, depuis que j'ai mis à jour mon coffre fort, tout mon café disparait régulièrement ! Je suis convaincu qu'il s'agit d'un des nombreux méfaits de cette fameuse Terreur des Quincailliers, mais l'inspecteur refuse de me croire ! Vous voulez bien me prouver que c'est possible de trouver le mot de passe ? D'ailleurs le vendeur m'avait juré qu'il était inviolable ! Si vous arrivez à prouver le contraire, je vais enfin pouvoir porter plainte !»

Pour ce challenge il suffit de trouver le mot de passe qui valide le programme. Attention cepenndant, il ne fonctionne que avec Python 3.11.

> Format : 404CTF{mot de passe}

## Inputs
- python script:  [encore-une-mise-a-jour.py](./encore-une-mise-a-jour.py)


## Solution
Looking at the beginning of the python script, we see the use of new feature `Specializing adaptive interpreter`, added in `Python 3.11`:

```python
h = __import__('dis')
dico = {'adaptive': True}
```

From https://realpython.com/python311-new-features/#faster-code-execution, this is for faster execution:

```
PEP 659 describes a specializing adaptive interpreter. The main idea is to speed up code while it’s running by optimizing operations that are done often. This is similar to just-in-time (JIT) compilation, except that it doesn’t affect compilation. Instead, Python’s bytecode is adapted or changed on the fly.
```

This is why the code is ran multiple times (the function`check()`, that is):

```python
for i in range(10): #Checker 10 fois c'est mieux que 1 seule fois ! Comme ça je suis sûr de moi...
    if not (check(a, 1) or check(a, 1)):
        print('Non, c\'est pas ça...')
        exit(0)
```

Let's glance at this feature when running the code. From function `check()` code, we see that the function itself is disassembled, and `I` is counted in the bytecode and stored in variable `cody`. By running the function multiple times, there's a chance that we see this variable change, meaning that the generated bytecode has changed:

```python
def check(dumas, zola):
    cody = h.Bytecode(check, **dico).dis().count('I')
    carmen = 0

    if dumas[36] + cody * dumas[37] + dumas[38] == 25556:
        carmen += 1
    if dumas[3] + cody * dumas[4] + dumas[5] == 19862:
        carmen += 1
```

We certainly should not modify the function itself to print variable `cody`, but we can do the same from outside of the function, like so:

```python
a = "012345678901234567890123456789012345678901234567"
assert(len(a) == 48)
a = [ord(c) for c in a]

(...)

for i in range(10): #Checker 10 fois c'est mieux que 1 seule fois ! Comme ça je suis sûr de moi...
    check(a, 1); check(a, 1)
    cody = h.Bytecode(check, **dico).dis().count('I')
    print(cody)    
```

And the execution suggests that the generated bytecode is modified (optimized) after multiple iterations, so variable `cody` does change as a consequence:

```console
$ python3 test.py
48
518
518
518
1292
1292
1292
1292
1292
1292
1292
```

Now, what we have to do is resolve a problem with 48 variables (the length of the expected `dumas` input password), and 64 equations, wherethe 64 equations go by pairs:

```python
    if dumas[36] + cody * dumas[37] + dumas[38] == 25556: carmen += 1
    if dumas[36] + cody * dumas[37] + dumas[38] == 63482: carmen += 1    
    # (...)
    if dumas[3] + cody * dumas[4] + dumas[5] == 19862: carmen += 1
    if dumas[3] + cody * dumas[4] + dumas[5] == 49274: carmen += 1    
    # (...)
```
The last conditions we have:
- each variable shall be an ascii character: `dumas[i] > 0 and dumas[i] < 128 for i in range(48)`
- `carmen == 32`

That's a problem for the `Z3 solver`.

First we create our 48 variables as a list comprehension like so:

```python
# Create a list of 48 integers
dumas = [Int("x_%s" % i) for i in range(48)]
cody = 518 # or 1292
```

Then we create our solver and feed it with the conditions we have:

```python
# Create the SMT solver instance and feed it with constraints
s = Solver()
s.add(
    Or(dumas[0] + cody * dumas[1] + dumas[2] == 17234,      dumas[0] + cody * dumas[1] + dumas[2] == 42776),
    Or(dumas[0] + dumas[1] + cody * dumas[2] == 35329,      dumas[0] + dumas[1] + cody * dumas[2] == 87961),
    Or(dumas[12] + cody * dumas[13] + dumas[14] == 25080,   dumas[12] + cody * dumas[13] + dumas[14] == 62232),
    Or(dumas[12] + dumas[13] + cody * dumas[14] == 147438,  dumas[12] + dumas[13] + cody * dumas[14] == 59202),
    # (...)
    # Is it possible to do the following with a list comprehension ???
    And(dumas[0] > 0, dumas[0] < 128),
    And(dumas[1] > 0, dumas[1] < 128),
    And(dumas[2] > 0, dumas[2] < 128),
    # (...)
)

Finally, we solve the problem, evaluate the 48 variables and extract the expected password:

```python
if s.check() == sat:
    m = s.model()
    r = [m.evaluate(dumas[i]) for i in range(48)]
    m = ''.join([chr(i.as_long()) for i in r])
    print(m)
```

And it works!

```console
$ python3 sol.py
H!Dd&N-v4r$_f0r_5p3ciaLiz3d_0pCoD3S!|12T5Y22EML8
```

## Python code
Complete solution in [sol.py](./sol.py)

## Flag
404CTF{H!Dd&N-v4r$_f0r_5p3ciaLiz3d_0pCoD3S!|12T5Y22EML8}
